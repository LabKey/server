import org.labkey.gradle.task.ShowDiscrepancies
import org.labkey.gradle.util.BuildUtils
import org.labkey.gradle.util.GroupNames
import org.labkey.gradle.plugin.NpmRun

buildscript {
    repositories {
        maven {
            url "${artifactory_contextUrl}/plugins-release"
        }
        if (gradlePluginsVersion.contains("SNAPSHOT"))
        {
            maven {
                url "${artifactory_contextUrl}/plugins-snapshot-local"
            }

        }
    }
    dependencies {
        classpath "org.labkey.build:versioning:${versioningPluginVersion}"
    }
    configurations.all {
        // Check for updates every build for SNAPSHOT dependencies
        resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
    }

}

plugins {
    id "com.jfrog.artifactory" version "${artifactoryPluginVersion}" apply false
    id "com.github.node-gradle.node" version "${gradleNodePluginVersion}" apply false
    id "com.jfrog.bintray" version "${bintrayPluginVersion}" apply false
    id "org.owasp.dependencycheck" version "${owaspDependencyCheckPluginVersion}" apply false
//    id "com.github.ben-manes.versions" version "0.25.0"
}

allprojects {
    if (project.hasProperty('enableOwaspDependencyCheck'))
    {
        // Comment in to enable the tasks for owasp dependency checking
        apply plugin: 'org.owasp.dependencycheck'
        dependencyCheck {
            outputDirectory = "${project.rootProject.buildDir}/reports/dependencyCheck/${project.path.replaceAll(':', '_').substring(1)}"
        }
    }
    if (BuildUtils.shouldPublish(project) || BuildUtils.shouldPublishDistribution(project))
    {
        apply plugin: 'com.jfrog.artifactory'
    }
    project.tasks.withType(JavaCompile) {
        JavaCompile compile ->
            compile.options.incremental = true  // Gradle 3.4
            compile.options.encoding = 'UTF-8'
    }
}

// We need the tomcat home directory to run UI tests from within IntelliJ.
String tomcatDirProp = System.getenv('CATALINA_HOME') != null ? System.getenv('CATALINA_HOME') : System.properties['tomcat.home']

if (tomcatDirProp != null && !new File(tomcatDirProp).exists())
    throw new GradleException("Tomcat home directory ${tomcatDirProp} does not exist.")

//allprojects {
//    apply plugin: 'idea'
//    idea {
//        module {
//            outputDir new File(rootDir, "intellijBuild/${project.name}/classes/main")
//            testOutputDir new File(rootDir, "intellijBuild/${project.name}/classes/test")
//        }
//    }
//}

apply plugin: 'org.labkey.multiGit'
allprojects {
    // this configuration is needed only in server and testAutomation, but we leave it here (for now) to avoid duplication
    configurations {
        driver
    }
    configurations.driver.setDescription("Dependencies used for SqlUtils")

    dependencies {
        //for SqlUtils
        driver "net.sourceforge.jtds:jtds:${jtdsVersion}"
        driver "org.postgresql:postgresql:${postgresqlDriverVersion}"
    }

    if (project.hasProperty('includeVcs'))
    {
        apply plugin: 'org.labkey.versioning'
        versioning {
            user = project.hasProperty('svn_user') ? project.property('svn_user') : 'cpas'
            password = project.hasProperty('svn_password') ? project.property('svn_password') : 'cpas'
        }
    }

    apply plugin: 'org.labkey.base'
    group  'org.labkey'
    version BuildUtils.getVersionNumber(project)

    tasks.withType(JavaCompile) { 
        sourceCompatibility = project.ext.sourceCompatibility
        targetCompatibility = project.ext.targetCompatibility
    }

    ext
            {
                vcsRevision = BuildUtils.getStandardVCSProperties(project).getProperty("VcsRevision")
                installerVersion = "${project.version}-${vcsRevision}"
            }
    repositories
            {
                // this if statement is necessary because the TeamCity artifactory plugin overrides
                // the repositories but does not use these artifactory_ urls.  For others who are
                // developing or building, you do need to specify the three artifactory_ properties
                // used below.
                if (project.hasProperty("artifactory_contextUrl"))
                {
                    maven {

                        url "${artifactory_contextUrl}/libs-release"

                        if (project.hasProperty('artifactory_user') && project.hasProperty('artifactory_password'))
                        {
                            credentials {
                                username = artifactory_user
                                password = artifactory_password
                            }
                            authentication {
                                basic(BasicAuthentication) // enable preemptive authentication to get around https://www.jfrog.com/jira/browse/RTFACT-4434
                            }
                        }
                    }
                    maven {
                        url "${artifactory_contextUrl}/libs-snapshot"

                        if (project.hasProperty('artifactory_user') && project.hasProperty('artifactory_password'))
                        {
                            credentials {
                                username = artifactory_user
                                password = artifactory_password
                            }
                            authentication {
                                basic(BasicAuthentication) // enable preemptive authentication to get around https://www.jfrog.com/jira/browse/RTFACT-4434
                            }
                        }
                    }
                }
                jcenter()
            }
    configurations.all {
        // Check for updates every build for SNAPSHOT dependencies
        resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
    }
    configurations.all
            {Configuration config ->
                resolutionStrategy {
                    // we force this version because we have compilation problems with version 1.9.2 of commons-beanutils, which is the version
                    // that is brought in by Gradle's conflict resolution as a result of our chosen versions for commons-validator (1.5.0) and commons-digester (1.8.1)
                    force "commons-beanutils:commons-beanutils:${commonsBeanutilsVersion}"
                    // we get different versions of slf4j-log4j12 and slf4j-api from different transitive dependencies.
                    force "org.slf4j:slf4j-log4j12:${slf4jLog4j12Version}"
                    force "org.slf4j:slf4j-api:${slf4jLog4jApiVersion}"
                    // force some newer versions than are brought in by mondrian (et al.)
                    force "xerces:xercesImpl:${xercesImplVersion}"
                    force "log4j:log4j:${log4jVersion}"
                    // force version for consistency with saml, query, LDK, and pipeline
                    force "commons-lang:commons-lang:${commonsLangVersion}"
                    // force version for consistency with workflow, api, SequenceAnalysis
                    force "org.apache.commons:commons-lang3:${commonsLang3Version}"
                    force "commons-dbcp:commons-dbcp:${commonsDbcpVersion}"
                    force "commons-io:commons-io:${commonsIoVersion}"
                    force "commons-logging:commons-logging:${commonsLoggingVersion}"
                    force "commons-pool:commons-pool:${commonsPoolVersion}"
                    // force version for consistency with query, saml, LDK, api
                    force "commons-collections:commons-collections:${commonsCollectionsVersion}"
                    // force version for ms2, saml, fileTransfer, harvest, scrumtime, api, accounts, docker
                    force "commons-codec:commons-codec:${commonsCodecVersion}"
                    // force version consistency in TCRdb, SequenceAnalysis, API
                    force "org.apache.commons:commons-math3:${commonsMath3Version}"
                    // force version for api, accounts, fileTransfer, harvest, scrumtime, docker
                    force "org.apache.httpcomponents:httpcore:${httpcoreVersion}"
                    // force version for api, docker, fileTransfer, harvest, scrumtime, accounts
                    force "org.apache.httpcomponents:httpclient:${httpclientVersion}"
                    // force version for SequenceAnalysis, api, cloud
                    force "com.google.guava:guava:${guavaVersion}"
                    // force version for accounts, api, query
                    force "javax.validation:validation-api:${validationApiVersion}"
                    // force version for accounts, docker, api, workflow
                    force "com.fasterxml.jackson.core:jackson-annotations:${jacksonAnnotationsVersion}"
                    // saml and query bring in different versions transitively; we force the later one
                    force "xalan:xalan:${xalanVersion}"
                    // genotyping brings in a much older version of this, so we force a newer version for compatibility
                    force "org.apache.commons:commons-compress:${commonsCompressVersion}"
                    // Transitive dependency of commons-compress -- Transitive dependency com.github.samtools:htsjdk:2.14.3 uses much older version
                    force "org.tukaani:xz:${tukaaniXZVersion}"
                    // force version for api, LDK, pipeline, query, saml, but not for the xsdDoc configuration, which requires
                    // an older version for the docflex library we use
                    if (!config.name.equals('xsdDoc'))
                        force "xml-apis:xml-apis:${xmlApisVersion}"
                    // cloud and SequenceAnalysis bring this in as a transitive dependency.  We resolve to the later version here to keep things consistent
                    force "com.google.code.gson:gson:${gsonVersion}"
                    // workflow (Activiti) brings in older versions of these libraries, so we need to force these versions
                    force "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}"
                    force "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
                    // The version of picard we depend on brings in an older version of htsjdk, but SequenceAnalysis depends on a later version
                    force "com.github.samtools:htsjdk:${htsjdkVersion}"
                    // Cloud module brings in earlier versions of this library, so we force the later one
                    force "org.apache.tika:tika-core:${tikaVersion}"
                    // Cloud module and workflow module bring in different versions
                    force "org.slf4j:jcl-over-slf4j:${jclOverSlf4jVersion}"
                    // OpenLDAPSync and premium have transitive dependency on a broken version of MINA
                    force "org.apache.mina:mina-core:${apacheMinaVersion}"
                    // saml has transitive dependencies on old versions of batik and xmlgraphics-commons, which conflict with more recent versions in api
                    force "org.apache.xmlgraphics:batik-css:${batikVersion}"
                    force "org.apache.xmlgraphics:xmlgraphics-commons:${fopVersion}"
                    // force consistency in TCRdb, mspipeline, omerointegration
                    force "ch.qos.logback:logback-classic:${logbackVersion}"
                    force "ch.qos.logback:logback-core:${logbackVersion}"
                    // force consistency in TCRdb, WNPRC
                    force "org.javassist:javassist:${javassistVersion}"

                    dependencySubstitution {
                        // Because the client api artifact name is not the same as the directory structure, we use
                        // Gradle's dependency substitution so the dependency will appear correctly in the pom files that
                        // are generated.  Because dependency substitution does not understand the use of classifiers, we cannot
                        // use this mechanism in general (plus, it's very slow for our many-module build).
                        if (project.findProject(BuildUtils.getRemoteApiProjectPath(gradle)) && BuildUtils.shouldBuildFromSource(project.project(BuildUtils.getRemoteApiProjectPath(gradle))))
                            substitute module('org.labkey:labkey-client-api') with project(BuildUtils.getRemoteApiProjectPath(gradle))
                        // mule and tika bring in different versions of bouncycastle package via transitive dependencies, but these versions
                        // result in a StackOverflow when starting tomcat so we substitute new libraries for both versions that are brought in.
                        substitute module('bouncycastle:bcprov-jdk14:138') with module("org.bouncycastle:bcprov-jdk15on:${bouncycastleVersion}")
                        substitute module('bouncycastle:bcmail-jdk14:138') with module("org.bouncycastle:bcpkix-jdk15on:${bouncycastleVersion}")
                        substitute module('bouncycastle:bcprov-jdk15:1.45') with module("org.bouncycastle:bcprov-jdk15on:${bouncycastleVersion}")
                        substitute module('bouncycastle:bcmail-jdk15:138') with module("org.bouncycastle:bcpkix-jdk15on:${bouncycastleVersion}")

                        // jdk5 backport of guava has significant conflicts with guava 18+
                        substitute module('com.google.guava:guava-jdk5') with module("com.google.guava:guava:${guavaVersion}")

                        if (project.hasProperty('apacheTomcatVersion'))
                        {
                            // For in-flight features in 'platform' and 'commonAssays' repositories
                            substitute module('org.apache.tomcat:jasper') with module("org.apache.tomcat:tomcat-jasper:${apacheTomcatVersion}")
                            substitute module('org.apache.tomcat:jsp-api') with module("org.apache.tomcat:tomcat-jsp-api:${apacheTomcatVersion}")
                        }
                    }
                }
            }
}


if (BuildUtils.shouldPublish(project) || BuildUtils.shouldPublishDistribution(project))
{
    artifactory {
        contextUrl = "${artifactory_contextUrl}"   //The base Artifactory URL if not overridden by the publisher/resolver
        publish {
            repository {
                repoKey = BuildUtils.getRepositoryKey(project)
                if (project.hasProperty('artifactory_user') && project.hasProperty('artifactory_password'))
                {
                    username = artifactory_user
                    password = artifactory_password
                }
                maven = true
            }
            defaults
                    {
                        publishPom = true
                        publishIvy = false
                    }
        }
    }

    artifactoryPublish.skip = true
}

subprojects {
    task("showRepos", group: "Help", description: "Show the list of repositories currently in use.").doLast({
        repositories.each{
            println "repository: ${it.name} (${it.hasProperty("url") ? it.url : it.getDirs()})"
        }
    })
    project.task("showConfigs", group: "help", description: "Show all the configurations available in the project and their published artifacts")
        .doLast({
            project.configurations.forEach({
                Configuration config ->
                    println(config.name + ": (${config.getDescription()})")
            })
        })
    
    task("allDepInsight",
            type: DependencyInsightReportTask,
            group: "Help",
            description: "Displays the insight into a specific dependency across all projects")
    task("allDependencies",
            type: DependencyReportTask,
            group: "Help",
            description: "Displays the dependencies for all projects")
}

// We copy the resource files to a separate directory so they can be copied to jsptmp directory
// for use in compiling JSPs.  Copying directly from the project.sourceSets.webapp.output for the JSP
// task for api does not work when modules may be evaluated before the api module is evaluated.  Attempts to
// declare evaluationDependsOn(:server:api) for each of these projects did not work.
// This task is defined at the root to eliminate problems with evaluation order
project.task("copyTagLibsBase",
        type: Copy,
        {CopySpec copy ->
            copy.from "${BuildUtils.getApiProjectPath(gradle).replace(":", "/").substring(1)}/webapp"
            copy.into "${project.buildDir}/webapp"
            copy.include 'WEB-INF/web.xml'
            copy.include 'WEB-INF/*.tld'
            copy.include 'WEB-INF/tags/**'
        }
)

project.task("showDiscrepancies",
                group: "Help",
                type: ShowDiscrepancies,
                description: "Report external dependencies that have more than one version referenced in the modules in this build"
)

project.task(
        'getModulesManifest',
        group: GroupNames.DISTRIBUTION,
        description: "Creates a csv file with a list of the modules for each distribution. By default it will be " +
                "placed in a directory called manifests in the root of this labkey installation. Specify another " +
                "directory by using \"-PmanifestDir\". The default file name is distributionModules.csv; specify " +
                "another name using \"-PmanifestFileName\"."
).doLast({
    String manifestDir = "${project.getRootProject().getProjectDir()}/manifests"
    String manifestFileName = "distributionModules.csv"

    if (project.hasProperty("manifestDir")) {
        manifestDir = project.manifestDir
    }

    if (project.hasProperty("manifestFileName")) {
        manifestFileName = project.manifestFileName
    }

    project.mkdir(manifestDir)
    File manifestFile = project.file("${manifestDir}/${manifestFileName}")

    StringBuilder manifestString = new StringBuilder("distribution,moduleName\n")
    project.allprojects({Project sp ->
        if (sp.configurations.getNames().contains("distribution")) {
            String distName
            if (sp.getName().startsWith("test_")) {
                // This is for the test_*prc case.
                distName = sp.getName()
            }
            else {
                distName = sp.tasks.distribution.hasProperty("subDirName") ?
                        sp.tasks.distribution.subDirName :
                        sp.getName()
            }
            sp.configurations.distribution
                    .getAllDependencies()
                    .withType(ProjectDependency)
                    .each({dep ->
                manifestString.append("${distName},${dep.name}\n")
            })
        }
    })
    manifestFile.text = manifestString.toString()
})

project.task(
    'listNpmProjects',
    group: GroupNames.NPM_RUN,
    description:"List all projects that employ npm in their build"
).doLast({
    List<String> npmProjects = []
    project.allprojects({Project p ->
        if (p.getPlugins().hasPlugin(NpmRun.class))
            npmProjects.add("${p.path} (${NpmRun.useYarn(p) ? 'yarn' : 'npm'})")
    })
    if (npmProjects.size == 0)
        println("No projects found containing ${NpmRun.NPM_PROJECT_FILE}")
    else {
        println("The following projects use NPM in their builds:\n\t${npmProjects.join("\n\t")}\n")
    }
})
