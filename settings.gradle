
pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal {
            content {
                excludeGroupByRegex "org\\.labkey.*"
            }
        }
        maven {
            url "${artifactory_contextUrl}/plugins-release-no-proxy"
            mavenContent {
                releasesOnly()
            }
            content {
                includeGroup "org.labkey.build"
                includeGroup "org.labkey.versioning"
            }
        }
        if (gradlePluginsVersion.contains("SNAPSHOT") || versioningPluginVersion.contains("SNAPSHOT"))
        {
            mavenLocal()
            maven {
                url "${artifactory_contextUrl}/plugins-snapshot-local"
                mavenContent {
                    snapshotsOnly()
                }
                content {
                    includeGroup "org.labkey.build"
                    includeGroup "org.labkey.versioning"
                }
            }
        }
    }
    resolutionStrategy {
        eachPlugin {
            if (requested.id.id == 'org.labkey.versioning')
            {
                // Versioning isn't published with plugin markers
                useModule("org.labkey.build:versioning:${versioningPluginVersion}")
            }
            else if (requested.id.namespace == 'org.labkey.build')
            {
                // This doesn't really do anything. The jar on the classpath will take precedence
                useVersion("${gradlePluginsVersion}")
            }
        }
    }
}

buildscript {
    repositories {
        mavenCentral()
        gradlePluginPortal {
            content {
                excludeGroupByRegex "org\\.labkey.*"
            }
        }
        maven {
            url "${artifactory_contextUrl}/plugins-release"
            mavenContent {
                releasesOnly()
            }
        }
        if (gradlePluginsVersion.contains("SNAPSHOT")) {
            // For testing changes to the gradle plugins. Publish 'gradlePlugins' locally using 'publishToMavenLocal'.
            // Update 'gradlePluginsVersion' to match the plugin SNAPSHOT version.
            // You will need to rerun the publish task to pick up new changes.
            mavenLocal()
            maven {
                url "${artifactory_contextUrl}/plugins-snapshot-local"
                mavenContent {
                    snapshotsOnly()
                }
            }
        }
    }
    dependencies {
        classpath "org.labkey.build:gradlePlugins:${gradlePluginsVersion}"
    }
    configurations.configureEach {
        // Check for updates every build for SNAPSHOT dependencies
        resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
    }
}

rootProject.name="labkey-server"

apply from: 'gradle/settings/parameters.gradle'

import groovy.transform.CompileStatic
import org.labkey.gradle.util.BuildUtils


// Define known renamed packages. We can't define a resolution strategy here but this will trigger a build failure if
// a conflicting dependency is introduced. Note: This information isn't recognized by ':showDiscrepancies'
// https://docs.gradle.org/current/userguide/dependency_capability_conflict.html
dependencyResolutionManagement {
    components {
        all(RenamedDependencyRule)
    }
}

@CompileStatic
class RenamedDependencyRule implements ComponentMetadataRule {
    void execute(ComponentMetadataContext context) {
        context.details.with {
            // Make local and remote modules collide
            if (id.group == 'org.labkey.module') {
                allVariants {
                    it.withCapabilities {
                        it.addCapability('org.labkey', id.name, id.version)
                    }
                }
            }

            // 'net.hydromatic' is the new group coordinate for 'eigenbase' packages
            if (id.group == 'eigenbase') {
                allVariants {
                    it.withCapabilities {
                        // Declare that eigenbase:eigenbase-* packages provide net.hydromatic:eigenbase-* capability, but with an older version
                        // Affects 'eigenbase-properties', 'eigenbase-resgen', and 'eigenbase-xom'
                        it.addCapability('net.hydromatic', id.name, id.version)
                    }
                }
            }
            // 'org.codehaus.woodstox:woodstox-core-asl' moved to 'com.fasterxml.woodstox:woodstox-core' at version 5.0
            else if (id.group == 'org.codehaus.woodstox' && id.name == 'woodstox-core-asl') {
                allVariants {
                    it.withCapabilities {
                        it.addCapability('com.fasterxml.woodstox', 'woodstox-core', id.version)
                    }
                }
            }
            // Normalize bouncycastle dependencies to detect conflict across jdk variants
            else if (id.group == 'bouncycastle' || id.group == 'org.bouncycastle') {
                var fixedName = id.name

                // Strip '-jdkXX' suffix
                var splitAt = fixedName.indexOf("-jdk")
                if (splitAt >= 0) {
                    fixedName = fixedName.substring(0, splitAt)
                }

                // bcmail renamed to bcpkix at version 1.47
                if (fixedName == 'bcmail') {
                    fixedName = 'bcpkix'
                }

                // Insert '.' into old version numbers (e.g. '140' -> '1.40')
                var fixedVersion = id.version
                if (!fixedVersion.contains('.')) {
                    fixedVersion = "1." + fixedVersion.substring(1)
                }

                allVariants {
                    it.withCapabilities {
                        // Add normalized capability to catch conflicts
                        it.addCapability('org.bouncycastle', fixedName, fixedVersion)
                    }
                }
            }
            // 'org.graalvm.js:js' moved to 'org.graalvm.polyglot:js-community' at version 23.1.0
            else if (id.group == 'org.graalvm.js' && id.name == 'js') {
                allVariants {
                    it.withCapabilities {
                        it.addCapability('org.graalvm.polyglot', 'js-community', id.version)
                    }
                }
            }
        }
    }
}

/*
  This file is used to determine which projects will be configured during the Gradle build of LabKey Server.

  You need to provide only the leaves of the project tree here; a Gradle project will be created for each
  node in the tree with these leaves (e.g., 'server:modules:core' will create projects for ":server"
  ":server:modules" and ":server:modules:core").
 */

include BuildUtils.getEmbeddedProjectPath(gradle)
include BuildUtils.getMinificationProjectPath(gradle)

// A list of directory names or fully qualified module paths that correspond to modules to be excluded from configuration.
// Items may be individual module names (e.g. 'luminex'), module container names (e.g. 'customModules'), or paths (e.g., ':server:modules:commonAssays:flow')
// You must make sure to pass this list to the appropriate calls to `BuildUtils.includeModules`
List<String> excludedModules = []
if (hasProperty('excludedModules'))
{
    excludedModules.addAll("${excludedModules}".split(","))
}

if (new File(getRootDir(), BuildUtils.convertPathToRelativeDir(BuildUtils.getPlatformProjectPath(gradle))).exists()
        && !hasProperty('excludeBaseModules'))
{
    // The line below includes the set of modules for a minimally functional LabKey server
    BuildUtils.includeBaseModules(this.settings, excludedModules)

    // Some test modules require base modules to build JSPs.
    // TODO: Un-nest this 'if' once test modules can build without platform present.
    if (new File(getRootDir(), BuildUtils.convertPathToRelativeDir(BuildUtils.getTestProjectPath(gradle))).exists()
            && !hasProperty('excludeTestModules'))
    {
        // The line below will include the server/testAutomation project as well as the server/testAutomation/modules projects
        BuildUtils.includeTestModules(this.settings, rootDir, excludedModules)
    }
}
else if (new File(getRootDir(), BuildUtils.convertPathToRelativeDir(BuildUtils.getTestProjectPath(gradle))).exists())
{
    // Include test project even if test modules are excluded.
    include BuildUtils.getTestProjectPath(gradle)
}

if (hasProperty("ideaIncludeAllModules") && BuildUtils.isIntellijGradleRefresh(this))
{
    apply from: "gradle/settings/all.gradle" // Get all modules when refreshing gradle projects from IntelliJ
}
// Using the property 'moduleSet', you can apply a settings script from the gradle/settings directory with the name of the moduleSet
else if (hasProperty('moduleSet'))
{
    if (!new File("gradle/settings/${moduleSet}.gradle").exists())
    {
        def files = new File("gradle/settings").listFiles()
        if (files.length == 0)
        {
            throw new FileNotFoundException("No module set definitions found in '<labkey>/gradle/settings/'")
        }
        List<String> moduleSets = new ArrayList<>()
        for (File file : files)
        {
            moduleSets.add(file.getName().replace(".gradle", ""))
        }
        throw new FileNotFoundException(String.format("Module set '${moduleSet}' does not exist. Choose one of: %s (e.g. '-PmoduleSet=%s')", moduleSets.join(", "), moduleSets.get(0)))
    }
    apply from: "gradle/settings/${moduleSet}.gradle"
}
else
{

    // The line below recursively includes all modules in server/modules 
    BuildUtils.includeModules(this.settings, rootDir, [BuildUtils.SERVER_MODULES_DIR], excludedModules, true)

    // The line below includes all modules in server/modules, server/modules/platform, and server/modules/commonAssays, but not other module containers (e.g. server/modules/customModules)
    //BuildUtils.includeModules(this.settings, rootDir, [BuildUtils.SERVER_MODULES_DIR, BuildUtils.PLATFORM_MODULES_DIR, BuildUtils.COMMON_ASSAYS_MODULES_DIR], excludedModules)

    // The line below includes all modules in server/modules as well as modules within any module containers there (e.g. server/modules/platform)
    //BuildUtils.includeModules(this.settings, rootDir, [BuildUtils.SERVER_MODULES_DIR], excludedModules, true)

    // The line below includes all modules in the server/modules/customModules directory
    //BuildUtils.includeModules(this.settings, rootDir, [BuildUtils.CUSTOM_MODULES_DIR], excludedModules)

    // The line below includes all modules in the server/modules, server/modules/platform, server/modules/commonAssays, and server/modules/customModules directories
    //BuildUtils.includeModules(this.settings, rootDir, BuildUtils.SERVER_MODULE_DIRS, excludedModules)

    // The line below includes a set of individual modules (in this case, some EHR related modules)
    //BuildUtils.includeModules(this.settings, [":server:modules:tnprc_ehr",
    //                                         ":server:modules:tnprc_billing",
    //                                         ":server:modules:snd"])

    // The line below is an example of how to include a single module
    //include ":server:modules:workflow"
}

if (hasProperty('extraIncludes'))
{
    for (String extraInclude : "${extraIncludes}".split(","))
    {
        include extraInclude
    }
}

if (hasProperty('extraModuleDirs'))
{
    BuildUtils.includeModules(this.settings, rootDir, Arrays.asList("${extraModuleDirs}".split(",")), excludedModules)
}

if (hasProperty('inheritedDistPath'))
{
    include "${inheritedDistPath}"
}
